"""
Process and format data for display in Telegram.
"""
import pandas as pd
from typing import Dict, List, Any, Optional, Union
from datetime import datetime, timedelta
import random

from src.utils.logger import get_logger

logger = get_logger(__name__)

class DataProcessor:
    """
    Process and format data for display.
    """
    
    @staticmethod
    def format_accounts(accounts: List[Dict]) -> str:
        """
        Format a list of accounts into a text table.
        
        Args:
            accounts: List of account data.
            
        Returns:
            Formatted text table.
        """
        if not accounts:
            return "–ù–µ—Ç –¥–æ—Å—Ç—É–ø–Ω—ã—Ö —Ä–µ–∫–ª–∞–º–Ω—ã—Ö –∞–∫–∫–∞—É–Ω—Ç–æ–≤"
        
        # Create a DataFrame
        df = pd.DataFrame(accounts)
        
        # Select and rename columns
        selected_columns = ['id', 'name', 'status', 'currency']
        if all(col in df.columns for col in selected_columns):
            df = df[selected_columns]
            df.columns = ['ID', '–ù–∞–∑–≤–∞–Ω–∏–µ', '–°—Ç–∞—Ç—É—Å', '–í–∞–ª—é—Ç–∞']
            
            # Convert status codes to human-readable
            status_map = {
                1: '–ê–∫—Ç–∏–≤–Ω—ã–π',
                2: '–û—Ç–∫–ª—é—á–µ–Ω',
                3: '–ù–µ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω',
                7: '–ó–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞–Ω',
                9: '–ù–∞ —Ä–∞—Å—Å–º–æ—Ç—Ä–µ–Ω–∏–∏',
                100: '–ó–∞–∫—Ä—ã—Ç',
                101: '–õ—é–±–æ–π'
            }
            if '–°—Ç–∞—Ç—É—Å' in df.columns:
                df['–°—Ç–∞—Ç—É—Å'] = df['–°—Ç–∞—Ç—É—Å'].map(lambda x: status_map.get(x, f'–ù–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–π ({x})'))
            
            # Format as text table
            header = " | ".join(df.columns)
            separator = "-" * len(header)
            rows = [" | ".join(map(str, row)) for _, row in df.iterrows()]
            
            return f"{header}\n{separator}\n" + "\n".join(rows)
        else:
            # Fallback if expected columns are not found
            return "\n".join([f"{account.get('name', '–ë–µ–∑ –∏–º–µ–Ω–∏')} ({account.get('id', '–ë–µ–∑ ID')})" 
                             for account in accounts])
    
    @staticmethod
    def format_campaigns(campaigns: List[Dict]) -> str:
        """
        Format a list of campaigns into a text table.
        
        Args:
            campaigns: List of campaign data.
            
        Returns:
            Formatted text table.
        """
        if not campaigns:
            return "–ù–µ—Ç –¥–æ—Å—Ç—É–ø–Ω—ã—Ö –∫–∞–º–ø–∞–Ω–∏–π"
        
        # Create a DataFrame
        df = pd.DataFrame(campaigns)
        
        # Select and rename columns
        selected_columns = ['id', 'name', 'status', 'objective']
        if all(col in df.columns for col in selected_columns):
            df = df[selected_columns]
            df.columns = ['ID', '–ù–∞–∑–≤–∞–Ω–∏–µ', '–°—Ç–∞—Ç—É—Å', '–¶–µ–ª—å']
            
            # Format as text table
            header = " | ".join(df.columns)
            separator = "-" * len(header)
            rows = [" | ".join(map(str, row)) for _, row in df.iterrows()]
            
            return f"{header}\n{separator}\n" + "\n".join(rows)
        else:
            # Fallback if expected columns are not found
            return "\n".join([f"{campaign.get('name', '–ë–µ–∑ –∏–º–µ–Ω–∏')} ({campaign.get('id', '–ë–µ–∑ ID')})" 
                             for campaign in campaigns])
    
    @staticmethod
    def format_ads(ads: List[Dict]) -> str:
        """
        Format a list of ads into a text table.
        
        Args:
            ads: List of ad data.
            
        Returns:
            Formatted text table.
        """
        if not ads:
            return "–ù–µ—Ç –¥–æ—Å—Ç—É–ø–Ω—ã—Ö –æ–±—ä—è–≤–ª–µ–Ω–∏–π"
        
        # Create a DataFrame
        df = pd.DataFrame(ads)
        
        # Select and rename columns
        selected_columns = ['id', 'name', 'status']
        if all(col in df.columns for col in selected_columns):
            df = df[selected_columns]
            df.columns = ['ID', '–ù–∞–∑–≤–∞–Ω–∏–µ', '–°—Ç–∞—Ç—É—Å']
            
            # Format as text table
            header = " | ".join(df.columns)
            separator = "-" * len(header)
            rows = [" | ".join(map(str, row)) for _, row in df.iterrows()]
            
            return f"{header}\n{separator}\n" + "\n".join(rows)
        else:
            # Fallback if expected columns are not found
            return "\n".join([f"{ad.get('name', '–ë–µ–∑ –∏–º–µ–Ω–∏')} ({ad.get('id', '–ë–µ–∑ ID')})" 
                             for ad in ads])
    
    @staticmethod
    def format_insights(insights: List[Dict], account_name: str = "–ë–µ–∑ –∏–º–µ–Ω–∏") -> Optional[str]:
        """
        –§–æ—Ä–º–∞—Ç–∏—Ä—É–µ—Ç –¥–∞–Ω–Ω—ã–µ –∏–Ω—Å–∞–π—Ç–æ–≤ –≤ –Ω–æ–≤—ã–π —Ñ–æ—Ä–º–∞—Ç —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–π.
        
        Args:
            insights: –°–ø–∏—Å–æ–∫ –∏–Ω—Å–∞–π—Ç–æ–≤
            account_name: –ù–∞–∑–≤–∞–Ω–∏–µ –∞–∫–∫–∞—É–Ω—Ç–∞
            
        Returns:
            –û—Ç—Ñ–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–Ω—ã–π —Ç–µ–∫—Å—Ç —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è –∏–ª–∏ None –µ—Å–ª–∏ –Ω–µ—Ç –¥–∞–Ω–Ω—ã—Ö
        """
        if not insights:
            return None
        
        # –ü–æ–ª—É—á–∞–µ–º –¥–∞—Ç—ã –∏–∑ –ø–µ—Ä–≤–æ–≥–æ –∏–Ω—Å–∞–π—Ç–∞
        try:
            date_start = insights[0].get('date_start')
            date_stop = insights[0].get('date_stop')
            
            if not date_start or not date_stop:
                return None
                
            # –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ–º —Å—Ç—Ä–æ–∫–∏ –¥–∞—Ç –≤ –æ–±—ä–µ–∫—Ç—ã datetime
            start_date = datetime.strptime(date_start, '%Y-%m-%d')
            end_date = datetime.strptime(date_stop, '%Y-%m-%d')
            
            # –°–ª–æ–≤–∞—Ä—å —Ä—É—Å—Å–∫–∏—Ö –Ω–∞–∑–≤–∞–Ω–∏–π –º–µ—Å—è—Ü–µ–≤
            MONTHS = {
                1: '—è–Ω–≤–∞—Ä—è', 2: '—Ñ–µ–≤—Ä–∞–ª—è', 3: '–º–∞—Ä—Ç–∞', 4: '–∞–ø—Ä–µ–ª—è',
                5: '–º–∞—è', 6: '–∏—é–Ω—è', 7: '–∏—é–ª—è', 8: '–∞–≤–≥—É—Å—Ç–∞',
                9: '—Å–µ–Ω—Ç—è–±—Ä—è', 10: '–æ–∫—Ç—è–±—Ä—è', 11: '–Ω–æ—è–±—Ä—è', 12: '–¥–µ–∫–∞–±—Ä—è'
            }
            
            # –§–æ—Ä–º–∞—Ç–∏—Ä—É–µ–º –¥–∞—Ç—ã –≤ –Ω—É–∂–Ω–æ–º —Ñ–æ—Ä–º–∞—Ç–µ
            start_str = start_date.strftime('%d')
            end_str = end_date.strftime('%d')
            
            # –ï—Å–ª–∏ –º–µ—Å—è—Ü—ã —Ä–∞–∑–Ω—ã–µ, –¥–æ–±–∞–≤–ª—è–µ–º –Ω–∞–∑–≤–∞–Ω–∏—è –º–µ—Å—è—Ü–µ–≤
            if start_date.month != end_date.month:
                start_str = f"{start_str} {MONTHS[start_date.month]}"
                end_str = f"{end_str} {MONTHS[end_date.month]}"
            else:
                end_str = f"{end_str} {MONTHS[end_date.month]}"
                
        except Exception as e:
            logger.error(f"Error parsing dates: {str(e)}")
            return None
            
        # –°–æ–±–∏—Ä–∞–µ–º —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É
        total_spend = sum(float(i.get('spend', 0)) for i in insights)
        total_reach = sum(float(i.get('reach', 0)) for i in insights)
        total_clicks = sum(float(i.get('clicks', 0)) for i in insights)
        total_impressions = sum(float(i.get('impressions', 0)) for i in insights)
        
        # –í—ã—á–∏—Å–ª—è–µ–º CTR –∏ CPC
        ctr = (total_clicks / total_impressions * 100) if total_impressions > 0 else 0
        cpc = total_spend / total_clicks if total_clicks > 0 else 0
        
        # –ü–æ–ª—É—á–∞–µ–º –¥–∞–Ω–Ω—ã–µ –æ –∫–æ–Ω–≤–µ—Ä—Å–∏—è—Ö
        conversion_type = None
        conversions = 0
        
        # –°–Ω–∞—á–∞–ª–∞ –∏—â–µ–º –∫–∞—Å—Ç–æ–º–Ω—ã–µ –∫–æ–Ω–≤–µ—Ä—Å–∏–∏
        for insight in insights:
            for conversion in insight.get('conversions', []):
                action_type = conversion.get('action_type', '')
                if action_type.startswith('offsite_conversion.fb_pixel_custom.'):
                    conversion_type = action_type
                    conversions += float(conversion.get('value', 0))
                    break
            if conversion_type:
                break
        
        # –ï—Å–ª–∏ –∫–∞—Å—Ç–æ–º–Ω—ã—Ö –∫–æ–Ω–≤–µ—Ä—Å–∏–π –Ω–µ—Ç, –∏—â–µ–º –æ–±—ã—á–Ω—ã–µ –ª–∏–¥—ã
        if not conversion_type:
            for insight in insights:
                for conversion in insight.get('conversions', []):
                    action_type = conversion.get('action_type', '')
                    if action_type in ['lead', 'offsite_conversion.fb_pixel_lead']:
                        conversion_type = action_type
                        conversions += float(conversion.get('value', 0))
                        break
                if conversion_type:
                    break
        
        # –ï—Å–ª–∏ –Ω–µ—Ç –¥–∞–Ω–Ω—ã—Ö –æ –∫–æ–Ω–≤–µ—Ä—Å–∏—è—Ö, –≤–æ–∑–≤—Ä–∞—â–∞–µ–º None
        if not conversion_type or conversions == 0:
            return None
            
        # –†–∞—Å—Å—á–∏—Ç—ã–≤–∞–µ–º —Ü–µ–Ω—É –∫–æ–Ω–≤–µ—Ä—Å–∏–∏ –≤—Ä—É—á–Ω—É—é
        conversion_cost = total_spend / conversions if conversions > 0 else None
        logger.info(f"Calculated conversion cost for {account_name}: {conversion_cost} (spend: {total_spend}, conversions: {conversions})")
            
        # –í—ã–±–∏—Ä–∞–µ–º —Å–ª—É—á–∞–π–Ω—ã–π —ç–º–æ–¥–∑–∏
        emojis = ['üìú', 'üíå', 'üßß']
        random_emoji = random.choice(emojis)
            
        # –§–æ—Ä–º–∞—Ç–∏—Ä—É–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ
        message = [
            f"{random_emoji} –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –∑–∞ {start_str} - {end_str} ({account_name}):",
            "",
            f"–ö–æ–Ω–≤–µ—Ä—Å–∏–π: {int(conversions)}",
            f"–¶–µ–Ω–∞ –∫–æ–Ω–≤–µ—Ä—Å–∏–∏: ${conversion_cost:.2f}" if conversion_cost is not None else "–¶–µ–Ω–∞ –∫–æ–Ω–≤–µ—Ä—Å–∏–∏: –Ω/–¥",
            f"–°–ø–µ–Ω–¥: ${total_spend:.2f}\n",
            f"–û—Ö–≤–∞—Ç: {int(total_reach):,}".replace(",", " "),
            f"–ö–ª–∏–∫–∏: {int(total_clicks):,}".replace(",", " "),
            f"CTR: {ctr:.2f}%",
            f"CPC: ${cpc:.2f}\n",
            f"–¢–∏–ø –∫–æ–Ω–≤–µ—Ä—Å–∏–π: {conversion_type}"
        ]
        
        return "\n".join(message)
    
    @staticmethod
    def truncate_for_telegram(text: str, max_length: int = 4000) -> List[str]:
        """
        Truncate text to fit Telegram message limits.
        
        Args:
            text: The text to truncate.
            max_length: Maximum length of a message.
            
        Returns:
            List of message parts.
        """
        if len(text) <= max_length:
            return [text]
        
        # Split by lines to avoid cutting in the middle of a row
        lines = text.split('\n')
        
        parts = []
        current_part = []
        current_length = 0
        
        for line in lines:
            if current_length + len(line) + 1 > max_length:  # +1 for the newline
                # Current part is full, add it to parts and start a new one
                if current_part:
                    parts.append('\n'.join(current_part))
                current_part = [line]
                current_length = len(line)
            else:
                # Add line to the current part
                current_part.append(line)
                current_length += len(line) + 1  # +1 for the newline
        
        # Don't forget the last part
        if current_part:
            parts.append('\n'.join(current_part))
        
        return parts
    
    @staticmethod
    def convert_to_dataframe(data: List[Dict], 
                             level: str = 'campaign', 
                             date_field: str = 'date_start') -> pd.DataFrame:
        """
        Convert API data to a pandas DataFrame.
        
        Args:
            data: List of data dictionaries.
            level: The level of data (account, campaign, adset, ad).
            date_field: The name of the date field.
            
        Returns:
            A pandas DataFrame.
        """
        if not data:
            return pd.DataFrame()
        
        # Create DataFrame
        df = pd.DataFrame(data)
        
        # Convert date if present
        if date_field in df.columns:
            try:
                df[date_field] = pd.to_datetime(df[date_field])
            except Exception as e:
                logger.warning(f"Failed to convert dates: {str(e)}")
        
        return df 