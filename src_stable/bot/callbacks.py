"""
Callback query handlers for the Facebook Ads Telegram Bot.
"""
import json
import os
import logging
from typing import Dict, Any, List, Union
from aiogram import Router, F
from aiogram.types import CallbackQuery
from aiogram.utils.keyboard import InlineKeyboardBuilder, InlineKeyboardButton
from aiogram.exceptions import TelegramBadRequest

from src.api.facebook import FacebookAdsClient
from src.storage.database import get_session
from src.storage.models import User, Cache
from src.utils.export import export_data_to_csv, export_data_to_json, export_data_to_excel
from src.utils.message_formatter import format_insights
from src.utils.languages import get_text, get_language

# Setup logger
logger = logging.getLogger(__name__)

# Create a router for callback queries
callback_router = Router()

@callback_router.callback_query(F.data.startswith("stats:"))
async def stats_callback(callback: CallbackQuery):
    """
    Handle statistics request callbacks.
    Callback data format: stats:object_type:object_id:date_preset
    """
    try:
        await callback.answer()
    except Exception as e:
        logger.warning(f"Error answering stats callback: {str(e)}")
        # Continue even if we can't answer the callback
        pass
    
    # Get the user ID
    user_id = callback.from_user.id
    
    # Fix for the issue where bot ID might be used
    if user_id == 8113924050 or str(user_id) == "8113924050":
        from src.storage.database import get_session
        from src.storage.models import User
        
        # Try to find a valid user
        session = get_session()
        try:
            user = session.query(User).filter(User.telegram_id != 8113924050).first()
            if user:
                print(f"DEBUG: Replacing bot ID with user ID in stats callback: {user.telegram_id}")
                user_id = user.telegram_id
        except Exception as e:
            print(f"DEBUG: Error finding alternative user in stats callback: {str(e)}")
        finally:
            session.close()
    
    parts = callback.data.split(":")
    if len(parts) < 4:
        await callback.message.edit_text("‚ùå Invalid stats request format.")
        return
    
    _, object_type, object_id, date_preset = parts[:4]
    
    # Get the user's language
    lang = get_language(user_id)
    
    # Show loading message
    try:
        await callback.message.edit_text(get_text("loading_stats", lang), parse_mode="HTML")
    except TelegramBadRequest:
        # Message was deleted or can't be edited
        return
    
    client = FacebookAdsClient(user_id)  # Use the fixed user_id
    
    try:
        insights = []
        object_name = None
        
        # Get insights based on object type
        if object_type == "account":
            insights = await client.get_account_insights(object_id, date_preset)
            # –ü–æ–ø—ã—Ç–∫–∞ –ø–æ–ª—É—á–∏—Ç—å –∏–º—è –∞–∫–∫–∞—É–Ω—Ç–∞
            try:
                accounts = await client.get_ad_accounts()
                for account in accounts:
                    if account.get('id') == object_id:
                        object_name = account.get('name', object_id)
                        break
            except:
                object_name = object_id
        elif object_type == "campaign":
            insights = await client.get_campaign_insights(object_id, date_preset)
            # –ò–º—è –∫–∞–º–ø–∞–Ω–∏–∏ –ø–æ–ª—É—á–∏–º –∏–∑ –∫–æ–Ω—Ç–µ–∫—Å—Ç–∞ –∑–∞–ø—Ä–æ—Å–∞ –∏–ª–∏ –æ—Å—Ç–∞–≤–∏–º ID
            object_name = object_id
        elif object_type == "adset":
            insights = await client.get_adset_insights(object_id, date_preset)
            object_name = object_id
        elif object_type == "ad":
            insights = await client.get_ad_insights(object_id, date_preset)
            object_name = object_id
        else:
            await callback.message.edit_text(f"‚ùå Unknown object type: {object_type}")
            return
            
        if not insights:
            # Create navigation keyboard
            builder = InlineKeyboardBuilder()
            button_count = 0
            
            builder.add(InlineKeyboardButton(
                text=get_text("back_to_accounts", lang),
                callback_data="menu:accounts"
            ))
            button_count += 1
            
            builder.add(InlineKeyboardButton(
                text=get_text("main_menu", lang),
                callback_data="menu:main"
            ))
            button_count += 1
            
            # Add empty button for even grid if needed
            if button_count % 2 != 0:
                builder.add(InlineKeyboardButton(
                    text=" ",
                    callback_data="empty:action"
                ))
            
            # Set up 2-button grid
            builder.adjust(2)
            
            await callback.message.edit_text(
                get_text("no_stats_found", lang, object_type=get_text(object_type, lang)),
                reply_markup=builder.as_markup()
            )
            return
        
        # If object name is available, use it in the insights header
        display_name = object_name or object_id
        
        # Limit name length for display
        if len(display_name) > 40:
            display_name = display_name[:37] + "..."
        
        # Format insights data for display
        formatted_text = format_insights(insights, object_type, date_preset, user_id)
        
        # Replace the header with object name if needed
        obj_type_display = get_text(object_type, lang).capitalize()
        if formatted_text.startswith(f"<b>{get_text('insights_for', lang, type=obj_type_display, name='')}</b>"):
            # Replace header with object name included
            old_header = f"<b>{get_text('insights_for', lang, type=obj_type_display, name='')}</b>\n"
            new_header = f"<b>{get_text('insights_for', lang, type=obj_type_display, name=display_name)}</b>\n"
            formatted_text = formatted_text.replace(old_header, new_header)
        
        # –°–æ–∑–¥–∞–µ–º –∫–Ω–æ–ø–∫–∏ –Ω–∞–≤–∏–≥–∞—Ü–∏–∏ –¥–ª—è –≤–æ–∑–≤—Ä–∞—Ç–∞ –∫ —Å–ø–∏—Å–∫—É –∞–∫–∫–∞—É–Ω—Ç–æ–≤ –∏ –≥–ª–∞–≤–Ω–æ–º—É –º–µ–Ω—é
        builder = InlineKeyboardBuilder()
        button_count = 0
        
        # –ö–Ω–æ–ø–∫–∞ –≤–æ–∑–≤—Ä–∞—Ç–∞ –∫ —Å–ø–∏—Å–∫—É –∞–∫–∫–∞—É–Ω—Ç–æ–≤
        builder.add(InlineKeyboardButton(
            text=get_text("back_to_accounts", lang),
            callback_data="menu:accounts"
        ))
        button_count += 1
        
        # –ö–Ω–æ–ø–∫–∞ –≤–æ–∑–≤—Ä–∞—Ç–∞ –≤ –≥–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é
        builder.add(InlineKeyboardButton(
            text=get_text("main_menu", lang),
            callback_data="menu:main"
        ))
        button_count += 1
        
        # –ï—Å–ª–∏ –Ω–µ—á–µ—Ç–Ω–æ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –∫–Ω–æ–ø–æ–∫, –¥–æ–±–∞–≤–ª—è–µ–º –ø—É—Å—Ç—É—é –¥–ª—è –ø–æ–¥–¥–µ—Ä–∂–∞–Ω–∏—è —Å–µ—Ç–∫–∏ 2—Ö2
        if button_count % 2 != 0:
            builder.add(InlineKeyboardButton(
                text=" ",
                callback_data="empty:action"
            ))
        
        # –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º —Å–µ—Ç–∫—É - –ø–æ 2 –∫–Ω–æ–ø–∫–∏ –≤ —Ä—è–¥
        builder.adjust(2)
        
        # Send the formatted insights
        await callback.message.edit_text(
            formatted_text, 
            parse_mode="HTML",
            reply_markup=builder.as_markup()
        )
        
    except Exception as e:
        logger.error(f"Error in stats_callback: {str(e)}")
        
        # Create navigation keyboard even on error
        builder = InlineKeyboardBuilder()
        button_count = 0
        
        builder.add(InlineKeyboardButton(
            text=get_text("back_to_accounts", lang),
            callback_data="menu:accounts"
        ))
        button_count += 1
        
        builder.add(InlineKeyboardButton(
            text=get_text("main_menu", lang),
            callback_data="menu:main"
        ))
        button_count += 1
        
        # Add empty button for even grid if needed
        if button_count % 2 != 0:
            builder.add(InlineKeyboardButton(
                text=" ",
                callback_data="empty:action"
            ))
        
        # Set up 2-button grid
        builder.adjust(2)
        
        await callback.message.edit_text(
            f"‚ùå Error fetching insights: {str(e)}",
            reply_markup=builder.as_markup()
        )


@callback_router.callback_query(F.data.startswith("export:"))
async def export_callback(callback: CallbackQuery):
    """
    Handle export requests.
    Callback data format: export:user_id:export_key:format
    """
    try:
        await callback.answer()
    except Exception as e:
        logger.warning(f"Error answering export callback: {str(e)}")
        # Continue even if we can't answer the callback
        pass
    
    # Get the user ID
    user_id = callback.from_user.id
    
    # Fix for the issue where bot ID might be used
    if user_id == 8113924050 or str(user_id) == "8113924050":
        from src.storage.database import get_session
        from src.storage.models import User
        
        # Try to find a valid user
        session = get_session()
        try:
            user = session.query(User).filter(User.telegram_id != 8113924050).first()
            if user:
                print(f"DEBUG: Replacing bot ID with user ID in export callback: {user.telegram_id}")
                user_id = user.telegram_id
        except Exception as e:
            print(f"DEBUG: Error finding alternative user in export callback: {str(e)}")
        finally:
            session.close()
    
    parts = callback.data.split(":")
    if len(parts) < 4:
        await callback.message.edit_text("‚ùå Invalid export request format.")
        return
    
    # Use our user_id instead of the one from callback data
    _, _, export_key, export_format = parts
    
    # Show loading message
    try:
        await callback.message.edit_text("‚è≥ Preparing export file...", parse_mode="HTML")
    except TelegramBadRequest:
        # Message was deleted or can't be edited
        return
    
    # Get the cached data
    session = get_session()
    try:
        cache_data = Cache.get(session, export_key)
        if not cache_data:
            await callback.message.edit_text("‚ùå Export data not found or expired. Please try again.")
            return
            
        file_path = None
        filename = f"facebook_ads_export_{export_key.split(':')[-1]}"
        
        # Export in the requested format
        if export_format == "csv":
            file_path = export_data_to_csv(cache_data, filename)
        elif export_format == "json":
            file_path = export_data_to_json(cache_data, filename)
        elif export_format == "excel":
            file_path = export_data_to_excel(cache_data, filename)
        else:
            await callback.message.edit_text(f"‚ùå Unsupported export format: {export_format}")
            return
            
        # Send the file
        if file_path and os.path.exists(file_path):
            await callback.message.delete()
            with open(file_path, "rb") as file:
                await callback.message.answer_document(file, caption=f"üìä Facebook Ads data export in {export_format.upper()} format")
            
            # Clean up the file
            try:
                os.remove(file_path)
            except Exception:
                pass
        else:
            await callback.message.edit_text("‚ùå Failed to create export file.")
            
    except Exception as e:
        await callback.message.edit_text(f"‚ùå Error exporting data: {str(e)}")
    finally:
        session.close()


@callback_router.callback_query(F.data.startswith("menu:"))
async def menu_callback(callback: CallbackQuery):
    """
    Handle menu selection callbacks.
    Callback data format: menu:item
    """
    try:
        await callback.answer()
    except Exception as e:
        logger.warning(f"Error answering menu callback: {str(e)}")
        # Continue even if we can't answer the callback
        pass
    
    # Get the user ID
    user_id = callback.from_user.id
    
    # Fix for the issue where bot ID might be used
    if user_id == 8113924050 or str(user_id) == "8113924050":
        from src.storage.database import get_session
        from src.storage.models import User
        
        # Try to find a valid user
        session = get_session()
        try:
            user = session.query(User).filter(User.telegram_id != 8113924050).first()
            if user:
                print(f"DEBUG: Replacing bot ID with user ID in menu callback: {user.telegram_id}")
                user_id = user.telegram_id
        except Exception as e:
            print(f"DEBUG: Error finding alternative user in menu callback: {str(e)}")
        finally:
            session.close()
    
    parts = callback.data.split(":")
    if len(parts) < 2:
        return
    
    menu_item = parts[1]
    
    # Check user token validity for accounts option
    if menu_item == "accounts":
        from src.storage.database import get_session
        from src.storage.models import User
        
        session = get_session()
        try:
            user = session.query(User).filter_by(telegram_id=user_id).first()
            if not user or not user.is_token_valid():
                await callback.message.edit_text(
                    "‚ö†Ô∏è –í–∞—à —Ç–æ–∫–µ–Ω –¥–æ—Å—Ç—É–ø–∞ –∏—Å—Ç–µ–∫ –∏–ª–∏ –æ—Ç—Å—É—Ç—Å—Ç–≤—É–µ—Ç. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ –∫–æ–º–∞–Ω–¥—É /auth –¥–ª—è –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏–∏.",
                    parse_mode=None
                )
                return
        except Exception as e:
            print(f"DEBUG: Error checking token validity: {str(e)}")
        finally:
            session.close()
    
    try:
        if menu_item == "main":
            # –ü–æ–∫–∞–∑–∞—Ç—å –≥–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é
            from src.bot.keyboards import build_main_menu_keyboard
            await callback.message.edit_text(
                "üìã <b>–ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é</b>\n\n"
                "–í—ã–±–µ—Ä–∏—Ç–µ –Ω—É–∂–Ω—ã–π –ø—É–Ω–∫—Ç –º–µ–Ω—é:",
                parse_mode="HTML",
                reply_markup=build_main_menu_keyboard()
            )
            
        elif menu_item == "accounts":
            # First, try to delete the current message
            try:
                await callback.message.delete()
            except Exception as e:
                logger.warning(f"Could not delete message when going to accounts: {str(e)}")
            
            # Get the chat ID where we need to send the message
            chat_id = callback.message.chat.id
            
            # Since we can't rely on message.answer or properly create a Message object,
            # we'll implement the account listing logic directly here
            
            # Show loading message
            try:
                # Send a new loading message using the callback's bot property
                loading_message = await callback.bot.send_message(
                    chat_id,
                    "üîÑ –ó–∞–≥—Ä—É–∂–∞–µ–º —Å–ø–∏—Å–æ–∫ –≤–∞—à–∏—Ö —Ä–µ–∫–ª–∞–º–Ω—ã—Ö –∞–∫–∫–∞—É–Ω—Ç–æ–≤..."
                )
                
                # Get accounts directly
                fb_client = FacebookAdsClient(user_id)
                accounts = await fb_client.get_ad_accounts()
                
                if not accounts:
                    await loading_message.edit_text(
                        "‚ö†Ô∏è –£ –≤–∞—Å –Ω–µ—Ç –¥–æ—Å—Ç—É–ø–Ω—ã—Ö —Ä–µ–∫–ª–∞–º–Ω—ã—Ö –∞–∫–∫–∞—É–Ω—Ç–æ–≤.\n"
                        "–£–±–µ–¥–∏—Ç–µ—Å—å, —á—Ç–æ –≤–∞—à–∞ —É—á–µ—Ç–Ω–∞—è –∑–∞–ø–∏—Å—å Facebook –∏–º–µ–µ—Ç –¥–æ—Å—Ç—É–ø –∫ —Ä–µ–∫–ª–∞–º–Ω—ã–º –∞–∫–∫–∞—É–Ω—Ç–∞–º."
                    )
                    return
                
                # Import the keyboard builder
                from src.bot.keyboards import build_account_keyboard
                
                # Create keyboard for accounts
                keyboard = build_account_keyboard(accounts, add_stats=True)
                
                # Update the loading message with accounts list
                try:
                    await loading_message.edit_text(
                        "üìä <b>–í—ã–±–µ—Ä–∏—Ç–µ —Ä–µ–∫–ª–∞–º–Ω—ã–π –∞–∫–∫–∞—É–Ω—Ç:</b>",
                        parse_mode="HTML",
                        reply_markup=keyboard
                    )
                except TelegramBadRequest as e:
                    if "can't parse entities" in str(e):
                        # Try without HTML parsing
                        await loading_message.edit_text(
                            "üìä –í—ã–±–µ—Ä–∏—Ç–µ —Ä–µ–∫–ª–∞–º–Ω—ã–π –∞–∫–∫–∞—É–Ω—Ç:",
                            reply_markup=keyboard
                        )
                    else:
                        raise
                        
            except Exception as e:
                logger.error(f"Error handling accounts navigation: {str(e)}")
                # Try to send an error message
                try:
                    await callback.bot.send_message(
                        chat_id,
                        f"‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ –∞–∫–∫–∞—É–Ω—Ç–æ–≤: {str(e)}"
                    )
                except Exception as inner_error:
                    logger.error(f"Could not send error message: {str(inner_error)}")
            
        elif menu_item == "auth":
            # Show authentication info
            await callback.message.edit_text(
                "üîë <b>–ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ–± –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏–∏</b>\n\n"
                "–î–ª—è –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è –±–æ—Ç–∞ –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ –ø—Ä–æ–π—Ç–∏ –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏—é –≤ Facebook:\n\n"
                "1. –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ –∫–æ–º–∞–Ω–¥—É /auth –¥–ª—è –Ω–∞—á–∞–ª–∞ –ø—Ä–æ—Ü–µ—Å—Å–∞ –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏–∏\n"
                "2. –ü–µ—Ä–µ–π–¥–∏—Ç–µ –ø–æ —Å—Å—ã–ª–∫–µ –∏ –ø—Ä–µ–¥–æ—Å—Ç–∞–≤—å—Ç–µ –±–æ—Ç—É –¥–æ—Å—Ç—É–ø –∫ –≤–∞—à–∏–º –¥–∞–Ω–Ω—ã–º Facebook Ads\n"
                "3. –°–∫–æ–ø–∏—Ä—É–π—Ç–µ URL –ø–æ—Å–ª–µ –ø–µ—Ä–µ–Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏—è –∏ –æ—Ç–ø—Ä–∞–≤—å—Ç–µ –µ–≥–æ –±–æ—Ç—É\n\n"
                "–í–∞—à–∞ –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏—è –±—É–¥–µ—Ç –¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª—å–Ω–∞ –≤ —Ç–µ—á–µ–Ω–∏–µ 60 –¥–Ω–µ–π.",
                parse_mode="HTML"
            )
            
        elif menu_item == "help":
            # Show help text with available commands
            await callback.message.edit_text(
                "üìö <b>–î–æ—Å—Ç—É–ø–Ω—ã–µ –∫–æ–º–∞–Ω–¥—ã:</b>\n\n"
                "/start - –ü—Ä–∏–≤–µ—Ç—Å—Ç–≤–µ–Ω–Ω–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ –∏ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ –±–æ—Ç–µ\n"
                "/auth - –ê–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏—è –≤ Facebook\n"
                "/accounts - –°–ø–∏—Å–æ–∫ –≤–∞—à–∏—Ö —Ä–µ–∫–ª–∞–º–Ω—ã—Ö –∞–∫–∫–∞—É–Ω—Ç–æ–≤\n"
                "/campaigns [id_–∞–∫–∫–∞—É–Ω—Ç–∞] - –°–ø–∏—Å–æ–∫ –∫–∞–º–ø–∞–Ω–∏–π –¥–ª—è –∞–∫–∫–∞—É–Ω—Ç–∞\n"
                "/ads [id_–∫–∞–º–ø–∞–Ω–∏–∏] - –°–ø–∏—Å–æ–∫ –æ–±—ä—è–≤–ª–µ–Ω–∏–π –¥–ª—è –∫–∞–º–ø–∞–Ω–∏–∏\n"
                "/stats [id_–æ–±—ä–µ–∫—Ç–∞] [–ø–µ—Ä–∏–æ–¥] - –ü–æ–ª—É—á–µ–Ω–∏–µ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏\n"
                "/export - –≠–∫—Å–ø–æ—Ä—Ç –¥–∞–Ω–Ω—ã—Ö –≤ —Ä–∞–∑–ª–∏—á–Ω—ã—Ö —Ñ–æ—Ä–º–∞—Ç–∞—Ö\n"
                "/menu - –ü–æ–∫–∞–∑–∞—Ç—å –≥–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é\n"
                "/help - –ü–æ–∫–∞–∑–∞—Ç—å —ç—Ç—É —Å–ø—Ä–∞–≤–∫—É",
                parse_mode="HTML"
            )
        
    except TelegramBadRequest as e:
        # Message was deleted or can't be edited
        print(f"DEBUG: TelegramBadRequest in menu callback: {str(e)}")
        try:
            # Try to send error without parse_mode
            await callback.message.edit_text(f"‚ùå –û—à–∏–±–∫–∞: {str(e)}", parse_mode=None)
        except:
            pass
    except Exception as e:
        print(f"DEBUG: General exception in menu callback: {str(e)}")
        try:
            await callback.message.edit_text(f"‚ùå –û—à–∏–±–∫–∞: {str(e)}", parse_mode=None)
        except:
            pass 

@callback_router.callback_query(F.data.startswith("account_stats:"))
async def account_stats_callback(callback: CallbackQuery):
    """
    Handle account stats button presses.
    Callback data format: account_stats:account_id:account_name
    """
    try:
        await callback.answer()
    except Exception as e:
        logger.warning(f"Error answering account_stats callback: {str(e)}")
        # Continue even if we can't answer the callback
        pass
    
    # Get the user ID
    user_id = callback.from_user.id
    
    # Fix for the issue where bot ID might be used
    if user_id == 8113924050 or str(user_id) == "8113924050":
        from src.storage.database import get_session
        from src.storage.models import User
        
        # Try to find a valid user
        session = get_session()
        try:
            user = session.query(User).filter(User.telegram_id != 8113924050).first()
            if user:
                print(f"DEBUG: Replacing bot ID with user ID in account_stats callback: {user.telegram_id}")
                user_id = user.telegram_id
        except Exception as e:
            print(f"DEBUG: Error finding alternative user in account_stats callback: {str(e)}")
        finally:
            session.close()
    
    parts = callback.data.split(":")
    if len(parts) < 2:
        await callback.message.edit_text("‚ùå Invalid account stats request format.")
        return
    
    account_id = parts[1]
    account_name = parts[2] if len(parts) > 2 else account_id
    
    # Import the date preset keyboard
    from src.bot.keyboards import build_date_preset_keyboard
    
    # –£–ª—É—á—à–µ–Ω–Ω–æ–µ –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏–µ –∏–º–µ–Ω–∏ –∞–∫–∫–∞—É–Ω—Ç–∞
    display_name = account_name if account_name != account_id else account_id
    
    # –û–≥—Ä–∞–Ω–∏—á–∏–≤–∞–µ–º –¥–ª–∏–Ω—É –∏–º–µ–Ω–∏ –¥–ª—è –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è, –µ—Å–ª–∏ –æ–Ω–æ —Å–ª–∏—à–∫–æ–º –¥–ª–∏–Ω–Ω–æ–µ
    if len(display_name) > 40:
        display_name = display_name[:37] + "..."
    
    # Show date selection keyboard
    try:
        await callback.message.edit_text(
            f"üìÖ –í—ã–±–µ—Ä–∏—Ç–µ –ø–µ—Ä–∏–æ–¥ –¥–ª—è —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏ –∞–∫–∫–∞—É–Ω—Ç–∞ <b>{display_name}</b>:",
            parse_mode="HTML",
            reply_markup=build_date_preset_keyboard(account_id, "account", account_name)
        )
    except TelegramBadRequest as e:
        # Message was deleted or can't be edited
        logger.warning(f"Error showing date selection keyboard: {str(e)}")
        # Try without HTML
        try:
            await callback.message.edit_text(
                f"üìÖ –í—ã–±–µ—Ä–∏—Ç–µ –ø–µ—Ä–∏–æ–¥ –¥–ª—è —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏ –∞–∫–∫–∞—É–Ω—Ç–∞ {display_name}:",
                reply_markup=build_date_preset_keyboard(account_id, "account", account_name)
            )
        except Exception as text_error:
            logger.error(f"Failed to show date selection keyboard: {str(text_error)}")
            await callback.message.edit_text("‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–æ–±—Ä–∞–∑–∏—Ç—å –≤—ã–±–æ—Ä –ø–µ—Ä–∏–æ–¥–∞.")

@callback_router.callback_query(F.data.startswith("campaign_stats:"))
async def campaign_stats_callback(callback: CallbackQuery):
    """
    Handle campaign stats button presses.
    Callback data format: campaign_stats:campaign_id[:campaign_name]
    """
    try:
        await callback.answer()
    except Exception as e:
        logger.warning(f"Error answering campaign_stats callback: {str(e)}")
        # Continue even if we can't answer the callback
        pass
    
    # Get the user ID
    user_id = callback.from_user.id
    
    # Fix for the issue where bot ID might be used
    if user_id == 8113924050 or str(user_id) == "8113924050":
        from src.storage.database import get_session
        from src.storage.models import User
        
        # Try to find a valid user
        session = get_session()
        try:
            user = session.query(User).filter(User.telegram_id != 8113924050).first()
            if user:
                print(f"DEBUG: Replacing bot ID with user ID in campaign_stats callback: {user.telegram_id}")
                user_id = user.telegram_id
        except Exception as e:
            print(f"DEBUG: Error finding alternative user in campaign_stats callback: {str(e)}")
        finally:
            session.close()
    
    parts = callback.data.split(":")
    if len(parts) < 2:
        await callback.message.edit_text("‚ùå Invalid campaign stats request format.")
        return
    
    campaign_id = parts[1]
    campaign_name = parts[2] if len(parts) > 2 else campaign_id
    
    # –û–≥—Ä–∞–Ω–∏—á–∏–≤–∞–µ–º –¥–ª–∏–Ω—É –∏–º–µ–Ω–∏ –¥–ª—è –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è, –µ—Å–ª–∏ –æ–Ω–æ —Å–ª–∏—à–∫–æ–º –¥–ª–∏–Ω–Ω–æ–µ
    if len(campaign_name) > 40:
        display_name = campaign_name[:37] + "..."
    else:
        display_name = campaign_name
    
    # Import the date preset keyboard
    from src.bot.keyboards import build_date_preset_keyboard
    
    # Show date selection keyboard
    try:
        await callback.message.edit_text(
            f"üìÖ –í—ã–±–µ—Ä–∏—Ç–µ –ø–µ—Ä–∏–æ–¥ –¥–ª—è —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏ –∫–∞–º–ø–∞–Ω–∏–∏ <b>{display_name}</b>:",
            parse_mode="HTML",
            reply_markup=build_date_preset_keyboard(campaign_id, "campaign", campaign_name)
        )
    except TelegramBadRequest as e:
        # Message was deleted or can't be edited
        logger.warning(f"Error showing date selection keyboard: {str(e)}")
        # Try without HTML
        try:
            await callback.message.edit_text(
                f"üìÖ –í—ã–±–µ—Ä–∏—Ç–µ –ø–µ—Ä–∏–æ–¥ –¥–ª—è —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏ –∫–∞–º–ø–∞–Ω–∏–∏ {display_name}:",
                reply_markup=build_date_preset_keyboard(campaign_id, "campaign", campaign_name)
            )
        except Exception as text_error:
            logger.error(f"Failed to show date selection keyboard: {str(text_error)}")
            await callback.message.edit_text("‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–æ–±—Ä–∞–∑–∏—Ç—å –≤—ã–±–æ—Ä –ø–µ—Ä–∏–æ–¥–∞.")

@callback_router.callback_query(F.data.startswith("ad_stats:"))
async def ad_stats_callback(callback: CallbackQuery):
    """
    Handle ad stats button presses.
    Callback data format: ad_stats:ad_id[:ad_name]
    """
    try:
        await callback.answer()
    except Exception as e:
        logger.warning(f"Error answering ad_stats callback: {str(e)}")
        # Continue even if we can't answer the callback
        pass
    
    # Get the user ID
    user_id = callback.from_user.id
    
    # Fix for the issue where bot ID might be used
    if user_id == 8113924050 or str(user_id) == "8113924050":
        from src.storage.database import get_session
        from src.storage.models import User
        
        # Try to find a valid user
        session = get_session()
        try:
            user = session.query(User).filter(User.telegram_id != 8113924050).first()
            if user:
                print(f"DEBUG: Replacing bot ID with user ID in ad_stats callback: {user.telegram_id}")
                user_id = user.telegram_id
        except Exception as e:
            print(f"DEBUG: Error finding alternative user in ad_stats callback: {str(e)}")
        finally:
            session.close()
    
    parts = callback.data.split(":")
    if len(parts) < 2:
        await callback.message.edit_text("‚ùå Invalid ad stats request format.")
        return
    
    ad_id = parts[1]
    ad_name = parts[2] if len(parts) > 2 else ad_id
    
    # –û–≥—Ä–∞–Ω–∏—á–∏–≤–∞–µ–º –¥–ª–∏–Ω—É –∏–º–µ–Ω–∏ –¥–ª—è –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è, –µ—Å–ª–∏ –æ–Ω–æ —Å–ª–∏—à–∫–æ–º –¥–ª–∏–Ω–Ω–æ–µ
    if len(ad_name) > 40:
        display_name = ad_name[:37] + "..."
    else:
        display_name = ad_name
    
    # Import the date preset keyboard
    from src.bot.keyboards import build_date_preset_keyboard
    
    # Show date selection keyboard
    try:
        await callback.message.edit_text(
            f"üìÖ –í—ã–±–µ—Ä–∏—Ç–µ –ø–µ—Ä–∏–æ–¥ –¥–ª—è —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏ –æ–±—ä—è–≤–ª–µ–Ω–∏—è <b>{display_name}</b>:",
            parse_mode="HTML",
            reply_markup=build_date_preset_keyboard(ad_id, "ad", ad_name)
        )
    except TelegramBadRequest as e:
        # Message was deleted or can't be edited
        logger.warning(f"Error showing date selection keyboard: {str(e)}")
        # Try without HTML
        try:
            await callback.message.edit_text(
                f"üìÖ –í—ã–±–µ—Ä–∏—Ç–µ –ø–µ—Ä–∏–æ–¥ –¥–ª—è —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏ –æ–±—ä—è–≤–ª–µ–Ω–∏—è {display_name}:",
                reply_markup=build_date_preset_keyboard(ad_id, "ad", ad_name)
            )
        except Exception as text_error:
            logger.error(f"Failed to show date selection keyboard: {str(text_error)}")
            await callback.message.edit_text("‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–æ–±—Ä–∞–∑–∏—Ç—å –≤—ã–±–æ—Ä –ø–µ—Ä–∏–æ–¥–∞.") 

@callback_router.callback_query(F.data.startswith("empty:"))
async def empty_callback(callback: CallbackQuery):
    """
    Handle empty button presses.
    This is a placeholder for layout purposes only.
    """
    try:
        await callback.answer()
    except Exception as e:
        logger.warning(f"Error answering empty callback: {str(e)}")
        # –ò–≥–Ω–æ—Ä–∏—Ä—É–µ–º –æ—à–∏–±–∫–∏ –¥–ª—è –ø—É—Å—Ç–æ–π –∫–Ω–æ–ø–∫–∏ 